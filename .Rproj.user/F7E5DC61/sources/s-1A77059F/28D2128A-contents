---
title: "Step-by-step Guide"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{step-by-step}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(PanelPRO)
```



The overall structure of the package can be visualized as:

![workflow](../man/figures/pkg_flow.svg)

Each multi-gene model requires two inputs - database and pedigree. 

- Database

`PanelPRO` comes with a internal (default) database that can be loaded by `data(PanelProDataBase)`. It is a list of arrays containing our curated estimates of penetrances, prevalences, risk/hazard ratio for interventions etc (please see `?PanelProDataBase` for more details)

In`PanelPRO()` function, we will first build a model-specific database from selected genes and cancers by `buildDatabase`. There are some existing models in `BayesMendel` with predefined gene-cancer specifications.

```{r}
p <- PanelPRO:::MODELPARAMS
df <- data.frame(model_name = names(p))
df$cancers = lapply(p, `[[`, "CANCERS")
df$genes = lapply(p, `[[`, "GENES")
df
```

Using `model_spec = "BRCAPRO"` will be the same as `genes =  c("BRCA1", "BRCA2"), cancers = c("Breast", "Ovarian")`.

```{r}
brca_db1 <- buildDatabase(model_spec = "BRCAPRO")
brca_db2 <- buildDatabase(genes =  c("BRCA1", "BRCA2"), cancers = c("Breast", "Ovarian"))
identical(brca_db1, brca_db2)
```


- Pedigree

A pedigree dataframe where the columns are 

- `ID`: Unique numbered ID for each individual, should not contain duplicated entries
- `Sex`: 0 for female and 1 for male, will not allow missing entries
- `MotherID`: The unique ID for someone's mother
- `FatherID`: The unique ID for someone's father
- `isProband`: 1 if someone is proband, otherwise 0
- `CurAge`: Age of censoring (current age if the person is alive; age of death if the person is dead), [1-94] is allowed
- `isAffX`: The affection status of cancer X, 1 if diagnosed, 0 otherwise.
- `AgeX`: The age of diagnosis of cancer X, [1-94] is allowed
- `isDead`: 1 if someone is dead, 0 otherwise, missing entries will be assumed alive
- `race`: Character, expected values are `r PanelPRO:::RACE_TYPES`. It helps to modify penetrance
- `riskmod`: Character **list**, expected values are `r PanelPRO:::RISKMODS`
- `interAge`: Numeric **list**, the age of intervention for each riskmodifiers. For example, `riskmod = list("A", "B")`, `interAge = {45, 60}` will indicate `riskmod_A` takes place at the age of 45 and `riskmod_B` takes place at age 60, correspondingly.
- `Ancestry`: Character, expected values are `r PanelPRO:::ANCESTRY_TYPES`
- `Twins`: Numeric, 1 for the first set of twins in the family, 2 for the second set.. etc. Missing entries will be assumed 0 (not twin)

There can be additional columns with gene names for germline testing results (e.g. `BRCA1`, `BRCA2` ..etc). `ER`, `PR`, `CK14`, `CK5.6` and `HER2` are tumor markers associated with breast cancer, and will modify the likelihood of phenotypes associated with `BRCA1` and `BRCA2`. `MSI` are a tumor marker in colorectal cancer for `MLH1`, `MSH2` `MSH6` and `PMS2`.

To represent a cancer in the pedigree we need to use specific cancer codes:

```{r}
data.frame(PanelPRO:::CANCER_NAME_MAP)
```

For example, Breast cancer affection status and affect ages need to be represented as `isAffBC` and `AgeBC`, given `BC` maps to `Breast` in `PanelPRODataBase`. 

There are several caveats of the pedigree stucture. First, the unkown values must be explicily coded in `NA`. In particular, the meaning of age zero is defined by the user. If the user believe `0` is valid input, then we should set `age.zero.is.real=TRUE`, otherwise any age that is zero will be treated as `NA` (default). 

`PanelPRO` comes with an example pedigree `small.fam`.

```{r}
head(small.fam)
```

`checkFam` checks pedigree content, fixes minor inconsistencies and imputes missing ages. The function will return three lists - `ped_list` is a list of fixed pedigrees (usually of length 1 but might be more if the probands specified are disconnected), `lms` is a list of imputed ages corresponding to each fixed pedigree, and `proband` is a vector of the `ID`s of the proband. Please refer to function documentation `?checkFam` and `?ageImpute` for more information.

```{r, message=FALSE}
checkl <- checkFam(ped = small.fam, db =brca_db1)
# the pedigree after sturcture check
checked_fam_structure <- do.call(rbind, checkl$ped_list)
head(checked_fam_structure)
```

```{r}
# the imputed ages
str(lapply(checkl$lms, head))
```


Next, `PanelPROCalc()` is for internal calculation of posterior probability and future risk. From their we calculate cancer penetrance (by `calcCancerPenetrance`) and penetrance resulting from death of other causes, adjusted for risk interventions. 

During multiple imputation, we first insert the imputed missing ages back to pedigree to make it complete. Then `calcLik` will generate a likelihood matrix for each individual and `pp.peelingParing` will use peeling algorithm, implemented in C++, to get posterior probability of germline mutation. Meanwhile, `calcFutureRisk` will generate a dataframe of future risk in 5-yr intervals.

The `posterior.prob` and `future.risk` take the average of result from 10 (default) imputations and report the range.

