# Depending on the sex, select the corresponding asymptote values or prepare for both
asymptotes_male <- data$asymptote_male_results
asymptotes_female <- data$asymptote_female_results
plot_distribution <- function(alphas, betas, thresholds, asymptotes, x_values, prob, color, add = FALSE) {
distributions <- mapply(function(alpha, beta, threshold, asymptote) {
pweibull(x_values - threshold, shape = alpha, scale = beta) * asymptote
}, alphas, betas, thresholds, asymptotes, SIMPLIFY = FALSE)
distributions_matrix <- matrix(unlist(distributions), nrow = length(x_values), byrow = FALSE)
mean_density <- rowMeans(distributions_matrix, na.rm = TRUE)
ci_lower <- apply(distributions_matrix, 1, quantile, probs = (1 - prob) / 2, na.rm = TRUE)
ci_upper <- apply(distributions_matrix, 1, quantile, probs = 1 - (1 - prob) / 2, na.rm = TRUE)
if (!add) {
plot(x_values, mean_density,
type = "l", col = color,
ylim = c(min(ci_lower, na.rm = TRUE), max(ci_upper, na.rm = TRUE)),
xlab = "Age", ylab = "Cumulative Penetrance", main = "Penetrance Curve with Credible Interval - Cumulative Probability"
)
} else {
lines(x_values, mean_density, col = color)
}
lines(x_values, ci_lower, col = color, lty = 2)
lines(x_values, ci_upper, col = color, lty = 2)
polygon(c(x_values, rev(x_values)), c(ci_lower, rev(ci_upper)), col = rgb(0, 0, 1, 0.1), border = NA)
}
if (sex == "Male") {
plot_distribution(alphas_male, betas_male, thresholds_male, asymptotes_male, x_values, prob, "blue")
legend_text <- "Male"
} else if (sex == "Female") {
plot_distribution(alphas_female, betas_female, thresholds_female, asymptotes_female, x_values, prob, "red")
legend_text <- "Female"
} else {
plot_distribution(alphas_male, betas_male, thresholds_male, asymptotes_male, x_values, prob, "blue")
plot_distribution(alphas_female, betas_female, thresholds_female, asymptotes_female, x_values, prob, "red", add = TRUE)
legend_text <- c("Male", "Female")
}
legend("topleft",
legend = legend_text,
col = c("blue", "red"),
lty = c(1, 1),
cex = 0.8
)
}
#' Plot Weibull Probability Density Function with Credible Intervals
#'
#' This function plots the Weibull PDF with credible intervals for the given data.
#' It allows for visualization of density curves for individuals based on their genetic
#' and demographic information.
#'
#' @param data Data frame, containing individual demographic and genetic information. Must include columns for 'sex', 'age', 'aff' (affection status), and 'geno' (genotype).
#' @param prob Numeric, the probability level for the credible intervals. Must be between 0 and 1.
#' @param max_age Integer, the maximum age considered in the analysis.
#' @param sex Character, specifying the sex of the individuals for the plot ("Male", "Female", or "NA" for not applicable). Default is "NA".
#'
#' @return A plot showing the Weibull PDF with credible intervals.
#'
plot_pdf <- function(data, prob, max_age, sex = "NA") {
if (prob <= 0 || prob >= 1) {
stop("prob must be between 0 and 1")
}
params_male <- calculate_weibull_parameters(
data$median_male_results,
data$first_quartile_male_results,
data$threshold_male_results
)
params_female <- calculate_weibull_parameters(
data$median_female_results,
data$first_quartile_female_results,
data$threshold_female_results
)
alphas_male <- params_male$alpha
betas_male <- params_male$beta
thresholds_male <- data$threshold_male_results
alphas_female <- params_female$alpha
betas_female <- params_female$beta
thresholds_female <- data$threshold_female_results
x_values <- seq(0, max_age, length.out = max_age + 1)
# Depending on the sex, select the corresponding asymptote values or prepare for both
asymptotes_male <- data$asymptote_male_results
asymptotes_female <- data$asymptote_female_results
plot_pdf_distribution <- function(alphas, betas, thresholds, asymptotes, x_values, prob, color, add = FALSE) {
pdf_distributions <- mapply(function(alpha, beta, threshold, asymptote) {
dweibull(x_values - threshold, shape = alpha, scale = beta) * asymptote
}, alphas, betas, thresholds, asymptotes, SIMPLIFY = FALSE)
pdf_matrix <- matrix(unlist(pdf_distributions), nrow = length(x_values), byrow = FALSE)
mean_density <- rowMeans(pdf_matrix, na.rm = TRUE)
ci_lower <- apply(pdf_matrix, 1, quantile, probs = (1 - prob) / 2, na.rm = TRUE)
ci_upper <- apply(pdf_matrix, 1, quantile, probs = 1 - (1 - prob) / 2, na.rm = TRUE)
if (!add) {
plot(x_values, mean_density,
type = "l", col = color,
ylim = c(min(ci_lower, na.rm = TRUE), max(ci_upper, na.rm = TRUE)),
xlab = "Age", ylab = "Probability Density", main = "Penetrance Curve with Credible Interval - Probability Distribution "
)
} else {
lines(x_values, mean_density, col = color)
}
lines(x_values, ci_lower, col = color, lty = 2)
lines(x_values, ci_upper, col = color, lty = 2)
polygon(c(x_values, rev(x_values)), c(ci_lower, rev(ci_upper)), col = rgb(0, 0, 1, 0.1), border = NA)
}
if (sex == "Male") {
plot_pdf_distribution(alphas_male, betas_male, thresholds_male, asymptotes_male, x_values, prob, "blue")
legend_text <- "Male"
} else if (sex == "Female") {
plot_pdf_distribution(alphas_female, betas_female, thresholds_female, asymptotes_female, x_values, prob, "red")
legend_text <- "Female"
} else {
plot_pdf_distribution(alphas_male, betas_male, thresholds_male, asymptotes_male, x_values, prob, "blue")
plot_pdf_distribution(alphas_female, betas_female, thresholds_female, asymptotes_female, x_values, prob, "red", add = TRUE)
legend_text <- c("Male", "Female")
}
legend("topleft",
legend = legend_text,
col = c("blue", "red"),
lty = c(1, 1),
cex = 0.8
)
}
#' Default Parameter Settings for Prior Distributions
#'
#' Default parameters for the prior distributions used in the \code{makePriors} function.
#'
#' @format A list with the following components:
#' \describe{
#'   \item{asymptote}{A list with components \code{g1} and \code{g2}, default values for the asymptote parameters.}
#'   \item{threshold}{A list with components \code{min} and \code{max}, default values for the threshold parameters.}
#'   \item{median}{A list with components \code{m1} and \code{m2}, default values for the median parameters.}
#'   \item{first_quartile}{A list with components \code{q1} and \code{q2}, default values for the first quartile parameters.}
#' }
#' @export
prior_params_default <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 15, max = 25),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
#' Default Risk Proportion Data
#'
#' Default proportions of people at risk used in the \code{makePriors} function.
#'
#' @format A data frame with the following columns:
#' \describe{
#'   \item{median}{Proportion of people at risk at the median age.}
#'   \item{first_quartile}{Proportion of people at risk at the first quartile age.}
#'   \item{max_age}{Proportion of people at risk at the maximum age.}
#' }
#' @export
risk_proportion_default <- data.frame(
median = 0.5,
first_quartile = 0.9,
max_age = 0.1
)
#' Default Distribution Data
#'
#' Default data frame structure with row names for use in the \code{makePriors} function.
#'
#' @format A data frame with the following columns:
#' \describe{
#'   \item{age}{Age values (NA for default).}
#'   \item{at_risk}{Proportion of people at risk (NA for default).}
#' }
#' @export
distribution_data_default <- data.frame(
row.names = c("min", "first_quartile", "median", "max"),
age = c(NA, NA, NA, NA),
at_risk = c(NA, NA, NA, NA)
)
#' Make Priors
#'
#' This function generates prior distributions based on user input or default parameters.
#' It is designed to aid in the statistical analysis of risk proportions in populations, particularly in the context of cancer research.
#' The distributions are calculated for various statistical metrics such as asymptote, threshold, median, and first quartile.
#'
#' @param data A data frame containing age and risk data. If NULL or contains NA values, default parameters are used.
#' @param sample_size Numeric, the total sample size used for risk proportion calculations.
#' @param cancer Character string, specifying the type of cancer, used in OR/RR ratio calculations.
#' @param ratio Numeric, the odds ratio (OR) or relative risk (RR) used in asymptote parameter calculations.
#' @param prior_params List, containing prior parameters for the beta distributions. If NULL, default parameters are used.
#' @param risk_proportion Data frame, with default proportions of people at risk.
#' @param baseline_data Data frame with the baseline risk data.
#'
#' @details
#' The function includes internal helper functions for normalizing median and first quartile values, and for computing beta distribution parameters.
#' The function handles various settings: using default parameters, applying user inputs, and calculating parameters based on sample size and risk proportions.
#'
#' If the OR/RR ratio is provided, the asymptote parameters are computed based on this ratio, overriding other inputs for the asymptote.
#'
#' The function returns a list of distribution functions for the asymptote, threshold, median, and first quartile, which can be used for further statistical analysis.
#'
#' @return A list of functions representing the prior distributions for asymptote, threshold, median, and first quartile.
#'
#' @seealso \code{\link{qbeta}}, \code{\link{runif}}
#' @export
makePriors <- function(data, sample_size, cancer, ratio, prior_params, risk_proportion, baseline_data) {
# Helper function definitions
normalize_median <- function(x) {
return((x - min_age) / (max_age - min_age))
}
normalize_first_quartile <- function(x) {
return((x - min_age) / (median_age - min_age))
}
compute_parameters_median <- function(stat, at_risk) {
median_norm <- normalize_median(stat)
alpha <- median_norm * at_risk
beta <- at_risk - alpha
return(list(m1 = alpha, m2 = beta))
}
compute_parameters_quartile <- function(stat, at_risk) {
quartile_norm <- normalize_first_quartile(stat)
alpha <- quartile_norm * at_risk
beta <- at_risk - alpha
return(list(q1 = alpha, q2 = beta))
}
compute_parameters_asymptote <- function(stat, at_risk) {
max_age_norm <- normalize_median(stat)
alpha <- max_age_norm * at_risk
beta <- at_risk - alpha
return(list(g1 = alpha, g2 = beta))
}
if (is.null(data) || all(is.na(data))) {
prior_params <- prior_params
} else {
if (any(is.na(data$age)) || any(!sapply(data$age, is.numeric))) {
stop("Missing or non-numeric age entries in the data. Add numeric ages.")
}
max_age <- data["max", "age"]
min_age <- data["min", "age"]
first_quartile_age <- data["first_quartile", "age"]
median_age <- data["median", "age"]
if (!is.null(data) && all(!is.na(data$age)) && all(is.na(data$at_risk)) && !is.null(sample_size)) {
risk_median <- risk_proportion$median * sample_size
risk_first_quartile <- risk_proportion$first_quartile * sample_size
risk_max_age <- risk_proportion$max_age * sample_size
} else {
if (any(is.na(data$at_risk)) || any(!sapply(data$at_risk, is.numeric))) {
stop("Missing or non-numeric risk entries in the data. Add individuals at risk or total sample size.")
}
risk_median <- data$at_risk[data$age == median_age]
risk_first_quartile <- data$at_risk[data$age == first_quartile_age]
risk_max_age <- data$at_risk[data$age == max_age]
}
res_median <- compute_parameters_median(median_age, risk_median)
res_first_quartile <- compute_parameters_quartile(first_quartile_age, risk_first_quartile)
res_asymptote <- compute_parameters_asymptote(max_age, risk_max_age)
prior_params <- list(
asymptote = list(g1 = res_asymptote$g1, g2 = res_asymptote$g2),
threshold = list(min = 0, max = min_age),
median = list(m1 = res_median$m1, m2 = res_median$m2),
first_quartile = list(q1 = res_first_quartile$q1, q2 = res_first_quartile$q2)
)
}
if (!is.null(ratio) && !is.null(cancer)) {
# Calculate the minimal value between Male and Female for each age
SERR_baseline_min <- pmin(baseline_data_default$Female, baseline_data_default$Male)
# Calculate the cumulative sum of the minimal risk and pick the lifetime risk
SEER_lifetime <- max(cumsum(SERR_baseline_min))
prior_params$asymptote <- list(g1 = SEER_lifetime * ratio, g2 = SEER_lifetime * ratio)
}
asymptote_distribution <- function(n) {
qbeta(runif(n), prior_params$asymptote$g1, prior_params$asymptote$g2)
}
threshold_distribution <- function(n) {
runif(n, prior_params$threshold$min, prior_params$threshold$max)
}
median_distribution <- function(n) {
qbeta(runif(n), prior_params$median$m1, prior_params$median$m2)
}
first_quartile_distribution <- function(n) {
qbeta(runif(n), prior_params$first_quartile$q1, prior_params$first_quartile$q2)
}
prior_distributions <- list(
asymptote_distribution = asymptote_distribution,
threshold_distribution = threshold_distribution,
median_distribution = median_distribution,
first_quartile_distribution = first_quartile_distribution,
prior_params = prior_params
)
return(prior_distributions)
}
# Load data
load("/Users/nicolaskubista/Dropbox (Partners HealthCare)/CCGCRN Hispanic Cohort Data/PenEstim/Data/carrierProbandFamilies_cohPedigree_MLH1.RData")
dat <- carrierProbandFamilies_cohPedigree_MLH1
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffCOL"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeCOL"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("MLH1" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "MLH1"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 5, max = 40),
median = list(m1 = 1, m2 = 1),
first_quartile = list(q1 = 1, q2 = 1)
)
# Use the SEER baseline
baselineMLH1 <- PPP::PanelPRODatabase$Penetrance["Colorectal","SEER","All_Races",,,"Net"]
library(PPP)
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffCOL"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeCOL"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("MLH1" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "MLH1"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 5, max = 40),
median = list(m1 = 1, m2 = 1),
first_quartile = list(q1 = 1, q2 = 1)
)
# Use the SEER baseline
baselineMLH1 <- PPP::PanelPRODatabase$Penetrance["Colorectal","SEER","All_Races",,,"Net"]
# Adjust Format
baselineMLH1_df <- as.data.frame(t(baselineMLH1))
colnames(baselineMLH1_df) <- c("Female", "Male")
baselineMLH1_df$Age <- as.numeric(rownames(baselineMLH1_df))
baselineMLH1_df <- baselineMLH1_df[, c("Female", "Male")]
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_sim_COL_vF2.1_noP <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 20000, ncores = 6, baseline_data = baselineMLH1_df , af  = PPP::PanelPRODatabase$AlleleFrequency[paste0("MLH1", "_anyPV"), "nonAJ"],
prior_params = prior_params, burn_in = 0.1, median_max = TRUE,  ageImputation = TRUE, removeProband = TRUE
))
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
library(clipp)
library(stats4)
library(MASS)
library(parallel)
library(kinship2)
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffCOL"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeCOL"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("MLH1" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "MLH1"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 5, max = 40),
median = list(m1 = 1, m2 = 1),
first_quartile = list(q1 = 1, q2 = 1)
)
# Use the SEER baseline
baselineMLH1 <- PPP::PanelPRODatabase$Penetrance["Colorectal","SEER","All_Races",,,"Net"]
# Adjust Format
baselineMLH1_df <- as.data.frame(t(baselineMLH1))
colnames(baselineMLH1_df) <- c("Female", "Male")
baselineMLH1_df$Age <- as.numeric(rownames(baselineMLH1_df))
baselineMLH1_df <- baselineMLH1_df[, c("Female", "Male")]
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_sim_COL_vF2.1_noP <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 20000, ncores = 6, baseline_data = baselineMLH1_df , af  = PPP::PanelPRODatabase$AlleleFrequency[paste0("MLH1", "_anyPV"), "nonAJ"],
prior_params = prior_params, burn_in = 0.1, median_max = TRUE,  ageImputation = TRUE, removeProband = TRUE
))
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffCOL"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeCOL"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("MLH1" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "MLH1"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 5, max = 40),
median = list(m1 = 1, m2 = 1),
first_quartile = list(q1 = 1, q2 = 1)
)
# Use the SEER baseline
baselineMLH1 <- PPP::PanelPRODatabase$Penetrance["Colorectal","SEER","All_Races",,,"Net"]
# Adjust Format
baselineMLH1_df <- as.data.frame(t(baselineMLH1))
colnames(baselineMLH1_df) <- c("Female", "Male")
baselineMLH1_df$Age <- as.numeric(rownames(baselineMLH1_df))
baselineMLH1_df <- baselineMLH1_df[, c("Female", "Male")]
# Data
dat <- load("/Users/nicolaskubista/Dropbox (Partners HealthCare)/CCGCRN Hispanic Cohort Data/PenEstim/Data/carrierProbandFamilies_cohPedigree_MLH1.RData")
dat <- carrierProbandFamilies_cohPedigree_MLH1
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffCOL"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeCOL" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeCOL"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("MLH1" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "MLH1"] <- "geno"
}
}
data <- do.call(rbind, lapply(dat, transformDF))
# Exploring different priors
prior_params <- list(
asymptote = list(g1 = 1, g2 = 1),
threshold = list(min = 5, max = 40),
median = list(m1 = 1, m2 = 1),
first_quartile = list(q1 = 1, q2 = 1)
)
# Prop
prop <- makePriors(
data = NULL,
sample_size = NULL,
cancer = "Colorectal",
ratio = NULL,
prior_params = prior_params,
risk_proportion = risk_proportion_default
)
out25 <-mhChain(
seed =2024, n_iter=4000, burn_in = 0.1, chain_id=1, data=data, ncores = 4, twins = NULL,
max_age=94, af = PPP::PanelPRODatabase$AlleleFrequency[paste0("MLH1", "_anyPV"), "nonAJ"],
baseline_data =  baseline_data_default,
prior_distributions = prop, removeProband = TRUE,
median_max = TRUE, max_penetrance = 1, ageImputation = TRUE, BaselineNC  = TRUE, var = c(0.1,0.1,2,2,5,5,5,5))
