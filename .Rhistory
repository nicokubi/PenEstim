#'   - `MotherID`: A numeric value representing the unique identifier for an individual's mother.
#'   - `FatherID`: A numeric value representing the unique identifier for an individual's father.
#'   - `isProband`: A numeric value where `1` indicates the individual is a proband and `0` otherwise.
#'   - `CurAge`: A numeric value indicating the age of censoring (current age if the person is alive or age at death if the person is deceased). Allowed ages range from `1` to `94`.
#'   - `isAff`: A numeric value indicating the affection status of cancer, with `1` for diagnosed individuals and `0` otherwise. Missing entries are not supported.
#'   - `Age`: A numeric value indicating the age of cancer diagnosis, encoded as `NA` if the individual was not diagnosed. Allowed ages range from `1` to `94`.
#'   - `Geno`: A column for germline testing or tumor marker testing results. Positive results should be coded as `1`, negative results as `0`, and unknown results as `NA` or left empty.
#' @param twins Identical twins or triplets in the family can be specifed. For example, to indicate that `ora024` and `ora027` are identical twins, and so are `aey063` and `aey064`,
#' then we can use the following as the twins arguement: twins <- list(c("ora024", "ora027"), c("aey063", "aey064"))
#' @param n_chains Number of chains for parallel computation. Default is 1.
#' @param n_iter_per_chain Number of iterations for each chain. Default is 10000.
#' @param ncores Number of cores for parallel computation. Default is 6.
#' @param baseline_data Data for the baseline risk estimates (probability of developing cancer), such as population-level risk from a cancer registry. Default is the allele frequency for MLH1 from the PanelPRO database.
#' @param max_age Maximum age considered for analysis. Default is 94.
#' @param removeProband Logical, indicating whether to remove probands from the analysis. Default is FALSE.
#' @param ageImputation Logical, indicating whether to perform age imputation. Default is FALSE.
#' @param median_max Boolean indicating whether to use the baseline median age or max_age as an upper bound for the median proposal. Default is TRUE.
#' @param BaselineNC Boolean indicating that the non-carrier penetrance is assumed to be the baseline penetrance. Default is TRUE.
#' @param var Vector of variances for the proposal distribution. Default is c(0.1, 0.1, 2, 2, 5, 5, 5, 5).
#' @param burn_in Fraction of results to discard as burn-in (0 to 1). Default is 0 (no burn-in).
#' @param thinning_factor Factor by which to thin the results. Default is 1 (no thinning).
#' @param distribution_data Data for generating prior distributions.
#' @param af Allele frequency for the risk allele. Default is 0.0001.
#' @param max_penetrance Maximum penetrance considered for analysis. Default is 1.
#' @param sample_size Optional sample size for distribution generation.
#' @param ratio Optional ratio parameter for distribution generation.
#' @param prior_params Parameters for prior distributions.
#' @param risk_proportion Proportion of risk for distribution generation.
#' @param summary_stats Boolean indicating whether to include summary statistics in the output. Default is TRUE.
#' @param rejection_rates Boolean indicating whether to include rejection rates in the output. Default is TRUE.
#' @param density_plots Boolean indicating whether to include density plots in the output. Default is TRUE.
#' @param plot_trace Boolean indicating whether to include trace plots in the output. Default is TRUE.
#' @param penetrance_plot Boolean indicating whether to include penetrance plots in the output. Default is TRUE.
#' @param penetrance_plot_pdf Boolean indicating whether to include PDF plots in the output. Default is TRUE.
#' @param probCI Probability level for confidence intervals in penetrance plots. Default is 0.95.
#' @return A list containing combined results from all chains, along with optional statistics and plots.
#' @importFrom stats rbeta runif
#' @importFrom parallel makeCluster stopCluster parLapply
#' @export
#'
PenEstim <- function(pedigree,
twins = NULL,
n_chains = 1,
n_iter_per_chain = 10000,
ncores = 6,
max_age = 94,
baseline_data = baseline_data_default,
removeProband = FALSE,
ageImputation = FALSE,
median_max = TRUE,
BaselineNC = TRUE,
var = c(0.1, 0.1, 2, 2, 5, 5, 5, 5),
burn_in = 0,
thinning_factor = 1,
distribution_data = distribution_data_default,
af = 0.0001,
max_penetrance = 1,
sample_size = NULL,
ratio = NULL,
prior_params = prior_params_default,
risk_proportion = risk_proportion_default,
summary_stats = TRUE,
rejection_rates = TRUE,
density_plots = TRUE,
plot_trace = TRUE,
penetrance_plot = TRUE,
penetrance_plot_pdf = TRUE,
probCI = 0.95) {
browser()
# Validate inputs
if (missing(pedigree)) {
stop("Error: 'pedigree' parameter is missing. Please provide a valid list of pedigrees.")
}
if (missing(n_chains) || !is.numeric(n_chains) || n_chains <= 0) {
stop("Error: 'n_chains' parameter is missing or invalid. Please specify a positive integer.")
}
if (missing(n_iter_per_chain) || !is.numeric(n_iter_per_chain) || n_iter_per_chain <= 0) {
stop("Error: 'n_iter_per_chain' parameter is missing or invalid. It must be a positive integer.")
}
if (n_chains > parallel::detectCores()) {
stop("Error: 'n_chains' exceeds the number of available CPU cores.")
}
# Create the seeds for the individual chains
seeds <- sample.int(1000, n_chains)
# Apply the transformation to adjust the format for the clipp package
data <- do.call(rbind, lapply(pedigree, transformDF))
# Create the prior distributions
prop <- makePriors(
data = distribution_data,
sample_size = sample_size,
ratio = ratio,
prior_params = prior_params,
risk_proportion = risk_proportion,
baseline_data = baseline_data
)
cores <- parallel::detectCores()
if (n_chains > cores) {
stop("Error: 'n_chains exceeds the number of available CPU cores.")
}
cl <- parallel::makeCluster(n_chains)
# Load required packages to the clusters
parallel::clusterEvalQ(cl, {
library(clipp)
library(stats4)
library(MASS)
library(parallel)
library(kinship2)
})
parallel::clusterExport(cl, c(
"mhChain", "mhLogLikelihood_clipp", "calculate_weibull_parameters", "validate_weibull_parameters", "prior_params",
"transformDF", "lik.fn", "mvrnorm", "var", "calculateEmpiricalDensity", "baseline_data", "calcPedDegree",
"seeds", "n_iter_per_chain", "burn_in", "imputeAges", "imputeAgesInit", "drawBaseline", "calculateNCPen", "drawEmpirical",
"data","twins", "prop", "af", "max_age", "BaselineNC", "median_max", "ncores", "removeProband"
), envir = environment())
results <- parallel::parLapply(cl, 1:n_chains, function(i) {
mhChain(
seed = seeds[i],
n_iter = n_iter_per_chain,
burn_in = burn_in,
chain_id = i,
data = data,
twins = twins,
ncores = ncores,
prior_distributions = prop,
max_age = max_age,
af = af,
max_penetrance = max_penetrance,
median_max = median_max,
baseline_data = baseline_data,
BaselineNC = BaselineNC,
var = var,
ageImputation = ageImputation,
removeProband = removeProband
)
})
# Check rejection rates and issue a warning if they are all above 90%
all_high_rejections <- all(sapply(results, function(x) x$rejection_rate > 0.9))
if (all_high_rejections) {
warning("Low acceptance rate. Please consider running the chain longer.")
}
# Apply burn-in and thinning
if (burn_in > 0) {
results <- apply_burn_in(results, burn_in)
}
if (thinning_factor > 1) {
results <- apply_thinning(results, thinning_factor)
}
# Extract samples from the chains
combined_chains <- combine_chains(results)
# Initialize variables
output <- list()
tryCatch(
{
if (rejection_rates) {
# Generate rejection rates
output$rejection_rates <- printRejectionRates(results)
}
if (summary_stats) {
# Generate summary statistics
output$summary_stats <- generate_summary(combined_chains)
}
if (density_plots) {
# Generate density plots
output$density_plots <- generate_density_plots(combined_chains)
}
if (plot_trace) {
# Generate trace plots
output$trace_plots <- plot_trace(results, n_chains)
}
if (penetrance_plot) {
# Generate penetrance plot
output$penetrance_plot <- plot_penetrance(combined_chains, prob = probCI, max_age = max_age)
}
if (penetrance_plot_pdf) {
# Generate PDF plots
output$penetrance_plot_pdf <- penetrance_plot_pdf(combined_chains, prob = probCI, max_age = max_age, sex = "NA")
}
},
error = function(e) {
# Handle errors here
cat("An error occurred in the output display: ", e$message, "\n")
}
)
output$combined_chains <- combined_chains
output$results <- results
output$data <- data
return(output)
}
out25 <-mhChain(
seed =999, n_iter=10, burn_in = 0.1, chain_id=2, data=data, ncores = 4, twins = NULL,
max_age=94, af = PPP::PanelPRODatabase$AlleleFrequency[paste0("PALB2", "_anyPV"), "nonAJ"],
baseline_data =  baseline_data_default,
prior_distributions = prop, removeProband = TRUE,
median_max = TRUE, max_penetrance = 1, ageImputation = TRUE, BaselineNC  = TRUE, var = c(0.1,0.1,2,2,5,5,5,5))
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
set.seed(27)
# Load data
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/NK_PenetranceEstimation/5_Data/PALB2_carrier_families.RData")
dat <- carrier_families_list
#Â Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffOC"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeOC"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("PALB2" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PALB2"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 3, g2 = 7),
threshold = list(min = 5, max = 40),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
# Use the SEER baseline (imported seperately)
baseline <- PPP::PanelPRODatabase$Penetrance["Ovarian","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Female", "Male")]
print(baseline_df)
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_COL_PALB2 <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 10, ncores = 2,
baseline_data = baseline_df , af  = 0.000057,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE,
ageImputation = FALSE, removeProband = FALSE
))
library(penetrance)
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
set.seed(27)
# Load data
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/NK_PenetranceEstimation/5_Data/PALB2_carrier_families.RData")
dat <- carrier_families_list
#Â Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffOC"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeOC"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("PALB2" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PALB2"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 3, g2 = 7),
threshold = list(min = 5, max = 40),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
# Use the SEER baseline (imported seperately)
baseline <- PPP::PanelPRODatabase$Penetrance["Ovarian","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Female", "Male")]
print(baseline_df)
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_COL_PALB2 <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 10, ncores = 2,
baseline_data = baseline_df , af  = 0.000057,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE,
ageImputation = FALSE, removeProband = FALSE
))
save(out_COL_PALB2, file = "out_COL_PALB2.Rdata")
library(penetrance)
# Load data
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/NK_PenetranceEstimation/5_Data/PALB2_carrier_families.RData")
dat <- carrier_families_list
#Â Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffOC"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeOC"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("PALB2" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PALB2"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 3, g2 = 7),
threshold = list(min = 5, max = 40),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
# Use the SEER baseline (imported seperately)
baseline <- PPP::PanelPRODatabase$Penetrance["Ovarian","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Female", "Male")]
print(baseline_df)
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_COL_PALB2 <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 10, ncores = 2,
baseline_data = baseline_df , af  = 0.000057,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE,
ageImputation = FALSE, removeProband = FALSE
))
save(out_COL_PALB2, file = "out_COL_PALB2.Rdata")
# print summary stats
out_COL_PALB2$summary_stats
library(penetrance)
remove.packages("penetrance")
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
set.seed(27)
library(penetrance)
library(penetrance)
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
set.seed(27)
# Load data
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/NK_PenetranceEstimation/5_Data/PALB2_carrier_families.RData")
dat <- carrier_families_list
#Â Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffOC"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeOC"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("PALB2" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PALB2"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 3, g2 = 7),
threshold = list(min = 5, max = 40),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
# Use the SEER baseline (imported seperately)
baseline <- PPP::PanelPRODatabase$Penetrance["Ovarian","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Female", "Male")]
print(baseline_df)
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_COL_PALB2 <- PenEstim(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 20000, ncores = 2,
baseline_data = baseline_df , af  = 0.000057,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE,
ageImputation = FALSE, removeProband = FALSE
))
devtools::document()
library(penetrance)
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(GGally)
set.seed(27)
#Â Data Preperation in the right format
for (i in seq_along(dat)) {
if ("ID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
# Change "isAffCOL" to "isAff" if "isAffCOL" is a column
for (i in seq_along(dat)) {
if ("isAffOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "isAffOC"] <- "isAff"
}
}
for (i in seq_along(dat)) {
if ("AgeOC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgeOC"] <- "Age"
}
}
for (i in seq_along(dat)) {
if ("PALB2" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PALB2"] <- "geno"
}
}
# Set the prior
prior_params <- list(
asymptote = list(g1 = 3, g2 = 7),
threshold = list(min = 5, max = 40),
median = list(m1 = 2, m2 = 2),
first_quartile = list(q1 = 6, q2 = 3)
)
# Use the SEER baseline (imported seperately)
baseline <- PPP::PanelPRODatabase$Penetrance["Ovarian","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Female", "Male")]
print(baseline_df)
#Run Estimation procedure with default prior setting
#Main Estimation for Female
system.time(out_COL_PALB2 <- penetrance(
pedigree  = dat, twins = NULL,n_chains = 1, n_iter_per_chain = 20000, ncores = 2,
baseline_data = baseline_df , af  = 0.000057,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE,
ageImputation = FALSE, removeProband = FALSE
))
pkgdown::build_site()
pkgdown::clean_site()`
pkgdown::clean_site()
pkgdown::clean_site()
pkgdown::build_site()
.Last.error
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
